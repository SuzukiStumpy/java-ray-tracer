package features.lights;

import features.Colour;
import features.Material;
import features.Point;
import features.Vector;
import org.jetbrains.annotations.NotNull;

import java.util.Objects;

/**
 * Base abstract class for lights
 *
 * @author Mark Edwards
 * @version July 14th, 2022
 */
public abstract class Light {
    private final Point position;
    private final Colour intensity;

    protected Light(@NotNull Point position, @NotNull Colour intensity) {
        this.position = new Point(position);
        this.intensity = new Colour(intensity);
    }

    // Generated methods to allow for collection comparisons/contains verification
    @Override
    public boolean equals(Object o) {
        if (this == o) return true;
        if (o == null || getClass() != o.getClass()) return false;
        Light light = (Light) o;
        return position.equals(light.position) && intensity.equals(light.intensity);
    }

    @Override
    public int hashCode() {
        return Objects.hash(position, intensity);
    }

    /**
     * @return the position where this light is located
     */
    public Point getPosition() {
        return new Point(this.position);
    }

    /**
     * @return The colour (intensity) of this light
     */
    public Colour getIntensity() {
        return new Colour(this.intensity);
    }

    /**
     * Basic Phong lighting model.  Given the various parameters, calculates the
     * colour of the resulting pixel.  Colour is generated by adding together
     * the material's ambient, diffuse and specular components, each weighted by
     * the angles between the individual vectors supplied.
     * @param m The material under consideration
     * @param light The light shining on the object
     * @param pointPosition The position of the point we are looking at
     * @param eye The camera/eye vector looking toward the point
     * @param normal The normal at the point.
     * @return The computed colour at the point under consideration
     */
    public static Colour lighting(
        @NotNull Material m,
        @NotNull Light light,
        @NotNull Point pointPosition,
        @NotNull Vector eye,
        @NotNull Vector normal) {

        Colour ambient;
        Colour diffuse;
        Colour specular;
        Colour black = new Colour(0,0,0);

        // Combine the surface colour with the light colour
        Colour effectiveColour = m.getColour().multiply(light.getIntensity());

        // Find the direction to the light source
        Vector lightVector = light.getPosition().subtract(pointPosition).normalize();

        // Compute the ambient contribution
        ambient = effectiveColour.multiply(m.getAmbient());

        // lightDotNormal is the cosine of the angle between the light vector
        // and the normal vector.  A negative number means the light is on the
        // other side of the surface.
        double lightDotNormal = lightVector.dot(normal);
        if (lightDotNormal < 0) {
            diffuse = black;
            specular = black;
        } else {
            // Compute the diffuse contribution
            diffuse = effectiveColour.multiply(m.getDiffuse()).multiply(lightDotNormal);

            // reflectDotEye represents the cosine of the angle between the
            // reflection vector and the eye vector.  A negative number here
            // means the light reflects away from the eye
            Vector reflectVector = lightVector.multiply(-1).toVector().reflect(normal);
            double reflectDotEye = reflectVector.dot(eye);

            if (reflectDotEye <= 0) {
                specular = black;
            } else {
                // Compute the specular contribution
                double factor = Math.pow(reflectDotEye, m.getShininess());
                specular = light.getIntensity().multiply(m.getSpecular()).multiply(factor);
            }
        }

        // Add the three components together to get the final shading for the point
        return ambient.add(diffuse).add(specular);
    }
}
